# 零件:I2C 实时时钟日历(PCF8563)

> 原文：<https://hackaday.com/2009/06/26/parts-i2c-real-time-clock-calendar-pcf8563/>

![pcf8563](img/690fa38249e026febca054604759502d.png "pcf8563")

[PCF8563](http://www.nxp.com/#/pip/pip=[pip=PCF8563_6]|pp=[t=pip,i=PCF8563_6]) 是一个带有 [I2C 接口](http://en.wikipedia.org/wiki/I%C2%B2C)的[实时时钟](http://en.wikipedia.org/wiki/Real-time_clock)/日历/闹钟芯片。这在主微控制器没有足够的资源用于中断驱动时钟的项目中非常有用。

休息之后，我们使用总线盗版来演示 PCF8563。在有限的时间内，你可以[得到你自己的巴士海盗](http://hackaday.com/2009/06/25/bus-pirate-preorders-open/)，完全组装好并运往世界各地，只需 30 美元。

![pcf8563](img/4aa8c0a5f43eda41dd44ee85578fca27.png "pcf8563")

**[PCF8563](http://www.nxp.com/#/pip/pip=[pip=PCF8563_6]|pp=[t=pip,i=PCF8563_6]) 实时时钟日历( [Octopart 搜索](http://octopart.com/parts/search?q=pcf8563)，$1.33)。[数据表](http://www.nxp.com/acrobat/datasheets/PCF8563_6.pdf) (PDF)。**

上面的原理图显示了 PCF8563 的基本电路。它需要一个简单的外部振荡器电路和一个 [32.768khz 手表晶体](http://mouser.com/Search/ProductDetail.aspx?R=AB26T-32.768KHZvirtualkey52750000virtualkey815-AB26T-32.768KHZ) (Q1)。振荡器输入引脚需要一个外部电容(C1，12pF)，但振荡器输出引脚已经有一个内部电容。C2 是电源引脚的一个 0.1uf 去耦电容。电源可以是 1.5 到 5.5 伏

数据手册还建议在电压输入端使用二极管。我们在测试中没有使用这个。

| **公交车海盗** | **PCF8563 (pin #)** |
| GND | GND (4) |
| MOSI | 民主行动党(5) |
| CLK | SCL (6) |
| 3.3 伏或 5 伏 | V+ (8) |
| Vpullup | V+ (8) |

我们使用我们的[总线盗版通用串行接口](http://www.buspirate.com)来演示该芯片，但是对于任何微控制器实现来说，事务序列都是相同的。如上表所示，我们将 Bus Pirate 连接到 PCF8563。我们将总线盗版设置为 I2C 模式(M，4)，并启用板载电源(大写“W”)。

不要忘记你需要在 I2C 总线上的某个地方安装[上拉电阻](http://en.wikipedia.org/wiki/Pull-up_resistor)。如果您使用的是总线盗版，将 Vpullup 输入连接到电路电源，然后按 p 配置上拉电阻(或连接硬件 v1a 的上拉跳线)。

*界面*

> I2C >(1)**<–搜索 I2C 地址宏**
> 搜索 7bit I2C 地址空间。
> 在:
> 0xA2 0xA3
> I2C >发现设备

PCF8563 I2C 写地址是 0xa2，读地址是 0xa3。您可以在数据手册中找到，或者使用总线盗版搜索宏(1)来检查所有可能的地址。

| **地址&#124;** | **注册名称&#124;** | **位** |
| 0x00 | 控制状态 1 |  |
| 0x01 | 控制状态 2 |  |
| 0x02 | VL 秒 | (0:6) |
| 0x03 | 分钟 | (0:6) |
| 0x04 | 小时 | (0:5) |
| 0x05 | 天 | (0:5) |
| 0x06 | 平日 | (0:2) |
| 0x07 | 月份 | (0:4) |
| 0x08 | 年 | (0:7) |
| *(参见第 6 页数据表)* |

该 RTC 有 16 个单字节寄存器，用于配置时钟和设置/检索时间。如上表所示，字节 0-8 包含状态和时间信息。高 7 字节配置报警、定时器和其他高级功能。我们只关注时钟功能。

这些寄存器就像 [I2C EEPROM](http://hackaday.com/2008/11/19/how-to-the-bus-pirate-universal-serial-interface/#EEPROM) 一样被访问。通过发送 I2C 写入地址(0xa2)、开始写入的地址(0-15)和要写入的数据字节来写入值。

分两步从芯片中读取值。首先，使用 write 命令定位读指针，但不发送任何数据字节。其次，使用读地址(0xa3)从写命令期间设置的位置开始读取字节。

> I2C > {*0x a2***2**0 30 12 31 1 5 9}
> I2C 开始条件
> 写:162 得到 ACK:是**<–I2C 写地址(0xa2=162)**
> 写:2 得到 ACK:是**<–寄存器开始写**
> 写:0 得到 ACK:是**<–秒(0)**
> 写:31 收到确认:是**<–月中某日(31)**
> 写:1 收到确认:是**<–星期几(1/周日)**
> 写:5 收到确认:是**<–月(5/5)**
> 写:9 收到确认:是**<–年(09/2009)**

通过写入寄存器 0x02 至 0x08 来设置时间。数值以二进制编码的十进制格式输入，所有数字日期表示都相当标准(参见数据表第 6-9 页)。我们将时间设置为 2009 年 5 月 31 日 12:30:00。

首先，发送一个 I2C 启动条件，告诉芯片监听它的地址(总线盗版命令)。接下来，发送 PFC8563 写地址( *0xa2* )，并将写指针设置到秒寄存器( **2** )。最后，将 7 个字节的数据写入地址 2-8 的时间寄存器。以 I2C 停止条件结束交易(总线盗版命令})。

> I2C>{0xa2 2 { 0xa3 r:7}
> I2C 开始条件
> 写:162 得到 ACK:是**<–发送写地址(0xa2=162)**
> 写:2 得到 ACK:是**<–设置指针到寄存器 2，秒**
> I2C 开始条件**<–重复开始条件**
> 写:163 得到 ACK:是**<–发送读地址(0xa3=163**

在读取时间之前，我们将总线盗版的输出模式设置为十进制(菜单“o”)。这会以更熟悉的十进制格式显示值。

检索时间需要两步。首先，部分写事务将存储器位置设置为读。然后，不发送任何数据，而是发送第二个起始条件({)和 PCF8563 I2C 读取地址(0xa3)，将芯片置于读取模式。最后，从寄存器 2 至 8 读取 7 个字节(r:7)。输出显示，自从我们设置时间以来，已经过去了一分钟。

> I2C>{0xa2 2 { 0xa3 r:7}
> I2C 起始条件
> 写:162 得到 ACK:是**<–发送写地址(0xa2=162)**
> 写:2 得到 ACK:是**<–设置指针指向寄存器 2、 秒**
> I2C 开始条件**<–重复开始条件**
> 写:163 得到 ACK:是**<–发送读地址(0xa3=163)**
> 批量读取 7 字节:**<–读回 7 字节**
> 34 32 12 31*33***37**9**<–星期几(33**

有时芯片似乎返回垃圾结果。上面的输出实际上是一个有效的时间读数，尽管它显然不是一周的第 33 天或一年中的第 37 个月。

每个寄存器都有几个“无关”位(参见数据手册第 6 页)。在大多数设备中,“无关”位总是被设置为 0，但 PCF8563 似乎在某些时间使用它们来保持容量。

星期几以二进制表示为 33 或 0b00100001。如果我们忽略高 5 位，我们得到 0b001，或 1/Sunday，一周中正确的一天。同样，忽略 month 的高三位(37 = 0b00100101)，给出 0b00101 或 5/May。

喜欢这个帖子？查看您可能错过的[部分帖子](http://hackaday.com/category/parts/)。想申请一个职位吗？请在评论中留下你的建议。