# 器件:32KB SPI SRAM 存储器(23K256)

> 原文：<https://hackaday.com/2009/03/02/parts-32kb-spi-sram-memory-23k256/>

![23k256ii](img/567bc7abeaadbe58ff7c3c0fd72ac583.png "23k256ii")

微芯片的新 [23K256](http://www.microchip.com/wwwproducts/Devices.aspx?dDocName=en539039) 是一种串行接口的 32 千字节 [SRAM](http://en.wikipedia.org/wiki/Static_random_access_memory) 存储芯片，提供 8 引脚 DIP 和 8 引脚 SO 封装。SRAM 和 [EEPROM](http://en.wikipedia.org/wiki/EEPROM) 一样，都是数据存储介质。存储在 SRAM 中的数据在没有恒定功率的情况下会丢失，但它真的很快，并且对写周期数没有限制。EERPOM 即使在没有电源的情况下也能存储数据，但是它速度很慢，通常限制在一百万个写周期左右。

32K SRAM 芯片通常有 15 条地址线和 8 条数据线，就像我们在 [CPLD 开发板](http://hackaday.com/2008/12/11/how-to-programmable-logic-devices-cpld/)上使用的 [IS61LV256AL](http://www.mouser.com/Search/ProductDetail.aspx?qs=sGAEpiMZZMt9mBA6nIyysJcHcPKaCSTLEF2cNpGsvgo%3d) 。23K256 只需要四条信号线，但牺牲了并行存储器接口的速度。这是向低引脚数微控制器添加额外存储器的好方法，无需布线 23 条信号走线。下面我们将向您展示如何连接这个芯片。

**微芯片 23K256，32K SPI SRAM ( [鼠标搜索](http://www.mouser.com/Search/Refine.aspx?Keyword=23k256)， [Octopart 搜索](http://octopart.com/search?q=23k256)，1.48 美元)。[数据表](http://ww1.microchip.com/downloads/en/DeviceDoc/22100C.pdf) **(PDF)。****

| **公交车海盗** | **23k 256(pin #)
T2** |
| 特许测量员 | /政务司司长(一) |
| 军事情报部门组织(Military Intelligence Service Organization) | 所以(2) |
| MOSI | 硅(5) |
| 时钟 | SCK (6) |
| GND | /按住(7) |
| GND | VSS (4) |
| +3 伏 | VCC (8) |

我们将 23K256 连接到我们的[总线盗版通用串行接口工具](http://hackaday.com/the-bus-pirate-universal-serial-interface/)，如表中所示。仅使用总线盗版的 3.3 伏电源为芯片供电非常重要，23K256 的额定电压不是 5 伏。

总线盗版是一种无需编写任何代码就能了解芯片的简单方法，但同样的原理也适用于 23K256 和任何微控制器。这次演示使用了最新版本的总线盗版固件(2009 年 2 月 26 日)，你可以从我们的[谷歌代码 SVN](http://code.google.com/p/the-bus-pirate/source/browse/) 下载。

> HiZ > m**<–选择模式**T2 1。HiZ
> ……
> 5。SPI
> …
> 模式>5**<–SPI 模式**
> 模式设置
> …**<–30k Hz，所有默认设置**
> SPI 就绪
> SPI>W**<–大写“W”使能电源**
> SPI>上的电源

首先，我们将 Bus Pirate 置于 30KHz 的 SPI 模式，并为所有选项选择默认设置。我们启用了巴士海盗的车载 3.3 伏电源，大写字母“W”。

*配置寄存器*

位 7，6 =字节(00)页(10)序列(01)模式
位 0 =保持禁用(1)

数据存储在 23K256 的 1024 个页面中，每个页面包含 32 个字节。读写范围由配置寄存器的位 7 和位 6 设置。可以按字节(00)、32 字节页面(10)或整个 32K (01)顺序访问存储。我们将在序列模式下工作，这使我们能够在 32K 的存储空间中的任何位置读写任何长度的数据。

当需要访问同一总线上的其它芯片时，hold 引脚用于暂停传输。配置寄存器的位 0 控制 hold 引脚。置 1 时，hold 引脚禁用。正常工作时，我们将 hold 接地，但通过设置位 0 可以完全禁用其功能。

通过发送*写配置命令* (0b00000001)和新设置来更改配置寄存器。

> SPI >[*0 B1***0b 01000001****<–更新配置寄存器**
> CS 使能
> 写入:0x 01**<–写入配置命令**
> 写入:0x 41**<–值写入**
> CS 禁用
> SPI >

我们通过使能 23K256 片选线([)来启动 SPI 处理。我们发送写配置命令( *0b1、0x01 或 1* )，然后是配置寄存器的新设置( **0b01000001、0x41** )。我们将位 6 设为顺序访问模式，将位 0 设为禁用保持引脚功能。位 5-1 不起作用，但数据手册说要一直写 0。事务通过禁用芯片选择信号(])结束。

> SPI >[*0b 101***r**
> CS 使能
> 写:0x 05**<–读配置寄存器**
> 读:0x 41**<–值读**
> CS 禁用
> SPI >

接下来，我们使用*读取配置寄存器命令* ( *0b00000101、0b101、0x05 或 5* )来验证设置是否被正确写入。该命令返回一个字节( **r** )，它应该与我们在前面的操作中写入的值(0x41 或 0b01000001)相匹配。

*数据访问*

现在我们可以在芯片上读写数据了。写操作从*数据写命令* (0b10、0x02 或 2)开始，随后是决定数据写入位置的两个字节。要存储的值在地址后发送。根据访问模式，单次操作可以填充一个字节、一个页面或整个存储器。

> SPI >[*0b 10***0 0**1 2 3 4 5 6 7 8 9 10】
> CS 使能
> 写入:0x 02**<–数据写入命令**
> 写入:0x 00**<–地址字节 1**
> 写入:0x 00**<–地址字节 2**
> 写入:0x 01**<–数据开始写入**

我们从*写数据命令* ( *0b10* )开始，并将写位置设置到芯片的开头( **0 0** )。我们总共发送 10 个值来存储，数字 1 到 10。

写入数据后，我们可以用*读数据命令* (0b00000011、0b11、0x03 或 3)读回数据。

> SPI >[*0b 11***0 0**r:10】
> CS 使能
> 写:0x 03**<–读取数据命令**
> 写:0x 00**<–起始地址字节 1**
> 写:0x 00**<–起始地址字节 2**
> 批量读取 0x0A 字节:**<–读出 10 字节**
> 0x01

我们发送读取数据命令( *0b11* )，然后是开始读取的地址( **0 0** )。然后我们读回 10 个字节(r:10)。这 10 个字节是数字 1 到 10，与我们在上一步中写的值相同。

喜欢这个帖子？查看您可能错过的[部分帖子](http://hackaday.com/category/parts/)。想申请一个职位吗？请在评论中留下你的建议。