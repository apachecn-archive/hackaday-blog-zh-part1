# AVR 编程 03:读取和编译代码

> 原文：<https://hackaday.com/2010/11/05/avr-programming-03-reading-and-compiling-code/>

在我们系列教程的最后一期中，我们在试验板上构建了一个简单的电路，并对 ATmega168 编程使其运行。这证明你知道如何遵循指示，但自己做每件事的灵光一现的时刻即将到来。这一次，您将认真阅读数据表，了解每一行示例代码的来源，并对您最近安装的编译器进行测试。我们将:

*   讨论位操作符以及它们在微控制器编码时是如何工作的
*   讨论 C 代码速记
*   回顾第 2 部分的示例代码，并讨论每一行代码的作用
*   学习编译代码

如果这是你第一次听说我们的 AVR 编程系列，回到[第 1 部分](http://hackaday.com/2010/10/23/avr-programming-introduction/)从头开始。否则，深呼吸，休息后我们会回来的。

**系列路线图:**

*   [AVR 编程 01:简介](http://hackaday.com/2010/10/23/avr-programming-introduction/ "Permanent Link to AVR Programming 01: Introduction")
*   [AVR 编程 02:硬件](http://hackaday.com/2010/10/25/avr-programming-02-the-hardware/ "Permanent Link to AVR Programming 02: The Hardware")
*   [AVR 编程 03:读取和编译代码](http://hackaday.com/2010/11/05/avr-programming-03-reading-and-compiling-code/ "Permanent Link to AVR Programming 03: Reading and compiling code")
*   [AVR 编程 04:写代码](http://hackaday.com/2010/11/19/avr-programming-04-writing-code-etc/)

## 先决条件

*   你一定对 C 代码有所了解。阅读它的能力可能已经足够好了，谷歌可以在你学习的时候帮你完成剩下的部分。
*   如果您有一个包含语法突出显示的文本编辑器，它会有所帮助。我纯粹是一个 Linux 用户，我喜欢根据自己的心情同时使用 Kate 和 Gedit。但我也经常使用外壳中的 nano。这是一个工具，你的选择纯粹是个人喜好。
*   从本系列的第 2 部分获取示例代码。我已将其嵌入下面，但您可能希望将其放在单独的窗口中以供参考。
*   数据表；硬件使用手册。获取 ATmega168 的数据表，因为我将引用具体页面作为示例。了解如何在数据手册中查找信息并将其转化为代码，将使您能够轻松使用 AVR 系列中的任何芯片。

## 按位运算符

尽管我们将用 C 语言编写代码，但在编写微控制器时，我们离硬件很近。因为这个**，你必须理解按位运算符**。不仅仅是一种，不是直觉上的，你应该足够了解它们，不用查字典就能把它们教给别人。

毫无疑问，我遇到的最好的解释来自[Eric Weddington]，他也是我的示例代码附带的 makefile 的作者之一。也被称为[编程 101。](http://www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&t=37871)读它，知道它，爱它。但是我会试着给那些懒于读完整课的人开一个速成班。

| 码符号 | 逻辑函数 |
| &#124; | 运筹学 |
| & | 和 |
| ~ | 不 |
| ^ | 异或运算 |
| << | 左移位 |
| >> | 右移 |

上面的列表显示了所有的代码符号及其逻辑操作。

*   或者–如果被比较的任一位或两位都为 1，则为真
*   AND–仅当比较的两位都为 1 时为真
*   NOT–产生相反的值(~1 = 0，~0 = 1)
*   XOR——异或……如果被比较的一位为 1，则为真；如果两者都不是或都不是，则为假
*   左移–将二进制数内的位左移。(1<<0 = 0b0001，1<<4 = 0b1000)
*   右移–将位向右移动所需的量(0b1000>>2 = 0b0010)

我们将在代码中一直使用 Shift Left，因为这是构建二进制数的快捷方式。我们总是用由八位组成的二进制数工作。这些位被编号为 0-7，因为对于微控制器来说，计数总是从 0 开始。因此，如果您想将第五位设置为逻辑高电平(“1”)，您可以将“1”左移 5:

```
1<<5
```

这将产生二进制数 0b00100000。如果这是儿戏，请转到下一部分。如果没有，读读【Eric 的】教程。

## c 代码速记

我倾向于在我的代码中使用速记，因为我的手经常因为打字过多而受伤(就像现在一样)。通过允许我输入更少的字符来完成相同的简单任务，这节省了一点旧的布洛芬月支出。这里有一个快速的例子表:

| 传统代码 | 速记等价物 |
| 值=值+1； | 值+= 1； |
| 值=值> > 1； | 值> > = 1； |
| value = value & bitMask | 值&=位掩码； |
| value = value &#124;位掩码； | value &#124;=位掩码； |
| 波特德=波特德^(1 < < 0)； | ^=港(1 < < 0)； |

因此，基本上，如果我使用同一个变量作为第一个[操作数](http://en.wikipedia.org/wiki/Operand)来设置一个变量，我只需将[操作符](http://en.wikipedia.org/wiki/Operator)放在等号前面，将第二个操作数放在等号后面，就可以完成相同的任务，而无需键入变量名两次。如果你理解了这句话，你做得很好！

跳转到样本代码

**伪代码**

开发代码时的一个好习惯是编写伪代码。用通俗易懂的语言清楚地说明你想做什么的东西。这是您的程序将采用的结构的大纲，它不应该包含任何特定的代码，但以后会被该代码替换:

```
//Setup the clock
  //prepare an interrupt every 1 second

//Setup the I/O for the LED

//toggle the LED during each interrupt
```

这个程序是如此简单，以至于伪代码似乎是不必要的，但它会让你专注，并有助于避免更大项目中的错误。

**实际代码**

下面嵌入了来自[第 2 部分示例代码](https://github.com/szczys/had_AVRtut_2/archives/master)的 main.c。花点时间将上面的伪代码部分与下面的实际代码块匹配起来。

```
/*
* Hackaday.com AVR Tutorial firmware
* written by: Mike Szczys (@szczys)
* 10/24/2010
*
* ATmega168
* Blinks one LED conneced to PD0
*
* http://hackaday.com/2010/10/25/avr-programming-02-the-hardware/
*/

#include <avr/io.h>
#include <avr/interrupt.h>

int main(void)
{

  //Setup the clock
  cli();			//Disable global interrupts
  TCCR1B |= 1<<CS11 | 1<<CS10;	//Divide by 64
  OCR1A = 15624;		//Count 15624 cycles for 1 second interrupt
  TCCR1B |= 1<<WGM12;		//Put Timer/Counter1 in CTC mode
  TIMSK1 |= 1<<OCIE1A;		//enable timer compare interrupt
  sei();			//Enable global interrupts

  //Setup the I/O for the LED

  DDRD |= (1<<0);		//Set PortD Pin0 as an output
  PORTD |= (1<<0);		//Set PortD Pin0 high to turn on LED

  while(1) { }			//Loop forever, interrupts do the rest
}

ISR(TIMER1_COMPA_vect)		//Interrupt Service Routine
{
  PORTD ^= (1<<0);		//Use xor to toggle the LED
}
```

前几行是对人眼有益的注释，不会被微控制器使用。对于单行注释，C 语言中的注释以两个斜杠(//)开头，对于多行注释，则用斜杠-星号(/*)和星号-斜杠(*/)括起来。写注释详细说明程序、它做什么、它在什么硬件上运行以及任何其他有用的信息是一个好主意。我发现我经常重用过去项目中的代码，文件顶部的一些信息有助于快速找到我要找的东西。

**包括**

接下来你看到的是包含:

```
#include <avr/io.h>
#include <avr/interrupt.h>
```

包括告诉编译器我们将使用其他文件中的内容。在本例中，我们在[第 1 部分](http://hackaday.com/2010/10/23/avr-programming-introduction/)中安装的交叉编译工具链附带了来自 [AVR Libc](http://www.nongnu.org/avr-libc/user-manual/) 的两个文件。这些是 C 文件，允许我们使用人类可读的(和可记忆的！)与芯片上的硬件一起工作时的代码。io.h 文件将所有支持的 AVR 芯片的头文件合并为一个。我们定义了在 makefile 中使用的处理器，当我们在本教程后面编译代码时，会自动从 io.h 中选择合适的头文件。

在我们的示例代码中，我使用了像 DDRD、波特、TCCR1B、OCR1A、TIMSK1 等名字。所有这些都有使用 io.h 文件指向的地址。这样，我们就可以通过所有 AVR 变体都相同的名称(如 PORTD)来调用芯片上的引脚，而不是像 0x0B 这样在不同芯片上具有不同功能的寄存器地址。很可能你需要在你使用的每一个 AVR 程序中都包含 io.h，这样做可以让你的代码更容易移植。只有在使用中断时才需要 interrupt.h 文件，这一点我们将在下一个代码块中讨论

**设置用于中断的时钟**

处理器需要时钟信号才能工作。AVR 芯片可以使用外部时钟，如晶体振荡器或陶瓷谐振器，但它们在出厂时配置为使用内部 RC 振荡器作为系统时钟(详情请参阅数据手册第 28 页)。ATmega168 的内部 RC 振荡器的工作频率约为 8.0 MHz，具体取决于电压稳定性和温度。它还启用了 DIV8 保险丝，将时钟信号分频至 1.0 MHz。对于示例程序，我希望 LED 在开和关之间闪烁，大约每秒钟变化一次。下面是设置该功能的代码块:

```
  //Setup the clock
  cli();			//Disable global interrupts
  TCCR1B |= 1<<CS11 | 1<<CS10;	//Divide by 64
  OCR1A = 15624;		//Count 15624 cycles for 1 second interrupt
  TCCR1B |= 1<<WGM12;		//Put Timer/Counter1 in CTC mode
  TIMSK1 |= 1<<OCIE1A;		//enable timer compare interrupt
  sei();			//Enable global interrupts

```

第一行与中断有关。中断是微处理器的一大特点。基本上，你告诉芯片注意某个条件。当它符合那个条件时，无论它在哪里，它都将停止正在做的事情，并运行一组不同的代码，称为中断服务程序(ISR)。因为我们将要改变一些与中断有关的设置，我们不希望任何事情(比如中断)在这个过程中阻止我们。我使用了一个可用的命令，因为我们在文件的开头包含了 interrupt.h。命令是[CLI()；](http://www.nongnu.org/avr-libc/user-manual/group__avr__interrupts.html#ga68c330e94fe121eba993e5a5973c3162)禁用所有中断。一旦我们完成了我们的设置，我们必须记得使用 [sei()再次启用它们；](http://www.nongnu.org/avr-libc/user-manual/group__avr__interrupts.html#gaad5ebd34cb344c26ac87594f79b06b73)命令。你可以看到我已经在这个代码块的底部完成了

现在我们要观察 1 秒钟的时间。这两个命令之间的四行用于设置一个计数器来完成这个任务。因为内部振荡器以 1 MHz 或每秒 100 万个周期运行，所以我们必须每 100 万个周期触发一次中断。该芯片最大的定时器是 16 位的，只能从 0 计数到 65，535。换句话说，我们没有一个计时器可以计数足够高来测量如此大量的周期。

幸运的是，我们可以选择在定时器中使用一个分频器，称为预分频器。为此，我们查看第 134 页的数据手册，其中有一张图表概述了时钟选择。它显示了将系统时钟除以 1、8、64、256 和 1024 的预分频器选项。知道我们想要计算 1，000，000 个周期，我们可以用一点数学来选择最佳预分频器:

```
1,000,000 / 1 = 1,000,000
1,000,000 / 8 = 125,000
1,000,000 / 64 = 15,625
1,000,000 / 256 = 3,906.25
1,000,000 / 1024 = 976.5625
```

数学只留给我们一个选择。这是因为使用 1 或 8 的预分频器会导致周期数大于 [65，536](http://www.google.com/#hl=en&expIds=17259,24416,26637,27060,27284,27357&sugexp=ldymls&xhr=t&q=2%5E16&cp=4&pf=p&sclient=psy&aq=f&aqi=h1g4&aql=&oq=2%5E16&gs_rfai=&pbx=1&fp=2304850557947867) ，因此我们的 16 位定时器无法计数到足够高的值。256 和 1024 的预分频器给出的结果不是整数。如果我们不使用一个整数，我们会引入一个不准确的时间，因为我们不能测量一个周期的一部分。64 的预分频器满足了我们的两个需求，它是一个小于 16 位计数器极限的整数。

我们如何设置这个预分频器？数据手册说明了一切。查看跨越 133 页和 134 页的“定时器/计数器 1 控制寄存器 B”(TCCR1B)，我们可以找到答案。图 15-5 显示了一个时钟设置表。在我们的例子中，我们需要在 TCCR1B 寄存器上将 CS10 和 CS11 设置为“1”。为此，我们使用 OR 运算符，将“1”左移至 CS10 和 CS11 位的位置:

```
  TCCR1B |= 1<<CS11 | 1<<CS10;
```

因为这是我们第一次真正的逐位数学，让我们深入研究一下。首先，我们只在寄存器上设置两位，所以我们不想只使用等号。如果我这样做了，这个命令将强制所有其他位为零。相反，我使用简写代码来使用 OR 运算符将 TCCR1B 与在 CS10 和 CS11 位的正确位置包含“1”的位掩码进行比较。TCCR1B 寄存器上设置为“1”的任何其他位将保持不变。

我在|=操作符的右边创建了一个位掩码。如 includes 部分所述，CS10 和 CS11 是在 io.h 中定义的，但查看 TCCR1B 寄存器，我们可以看到 CS10 位于位 0，CS11 位于位 1。如果你手写解决了你的数学问题，它会是这样的:

```
1<<CS11 | 1<<CS10;
1<<1 | 1<<0;
0b00000010 | 0b00000001;
0b00000011;
```

这是用于为任何目的设置任何位的方法。真的就这么简单。构建一个位掩码，并将其应用于寄存器或变量。请记住，要小心保存可能已经存储在寄存器或值中的数据，但在赋值时要使用 or 运算符。

现在我们有了计数器的分频时钟源，由于上面的计算，我们有了 15，625 个周期的目标值。我们可以使用定时器 1 的一种模式，即比较匹配清零定时器(CTC ),在精确的周期计数时触发中断。看一下数据手册的第 121 页，您会发现我们需要将 OCR1A 设置为目标值。我们将它设置为 15，624，比我们的周期计数少 1，因为微控制器定时器从零开始计数，而不是 1。这次我们将使用等号，因为该寄存器中没有存储其他值:

```
  OCR1A = 15624;
```

我还需要设置我想使用的定时器模式。第 133 页的表 15-4 有很多这方面的信息。如前所述，我想使用 CTC 模式，这样就可以将我在这张表上的选择缩小到两个。我可以在这两者之间进行选择，因为我知道我使用 OCR1A 的值作为计时器应该计数的最大值，或者说 TOP。该图告诉我将 TCCR1B 寄存器的 WGM12 位设为 1。：

```
  TCCR1B |= 1<<WGM12;
```

这可以与定时器预分频器同时完成，因为它们设置在同一个寄存器上。但分两步做也没问题，因为我使用了 OR 运算符，确保没有改变该寄存器的任何其他位。

下一步可能是新开发人员的“陷阱”。现在，我们的定时器已经设置好了，可以在适当的时间间隔触发中断。但是，如果我们不为该特定事件设置“中断使能”标志，中断将永远不会发生。数据手册第 136 页隐晦地讨论了定时器/计数器输出比较匹配中断使能的使用。将该位设为 1 将启用我们计划使用的 CTC 中断:

```
   TIMSK1 |= 1<<OCIE1A;
```

简单吧？多做几次就好了。这些芯片上的定时器有很多功能，费力地通过寄存器设置是你为这种能力付出的代价。但是现在我们准备好了 1 秒钟的中断。

**初始化输入/输出引脚**

当 AVR 芯片复位时，所有引脚都处于三态模式。在程序开始时，任何输入和输出引脚都需要为其所需的功能进行设置。从数据手册的第 73 页开始，您可以了解如何将引脚用作一般输入和输出。我们通常会关注每个引脚的三个寄存器:数据方向寄存器(DDR)、端口寄存器(Port)和引脚寄存器(pin)。每一个都有一个字母作为后缀，对应于我们正在使用的那组管脚。我已经将 LED 连接到端口 D，因此我需要使用端口 D 的 DDRD，如果我使用输入，还需要使用 PIND。

```
  //Setup the I/O for the LED

  DDRD |= (1<<0);		//Set PortD Pin0 as an output
  PORTD |= (1<<0);		//Set PortD Pin0 high to turn on LED
```

上面的代码用于设置一个 LED。将 DDRD 上的一个位设置为 1 将使相应的引脚成为输出。将其设置为零将使其成为一个输入。这里我设置了一个输出，因为我们在驱动一个 LED。通过将端口寄存器分别设置为 1 或 0，可以打开或关闭输出。因此，上面我使用了 PORTD 来打开位 0，它对应于连接到 LED 的引脚。

如果我们使用一个引脚作为输入，端口寄存器将用于使能或禁用内部上拉电阻，引脚寄存器将用于测量该引脚上当前的逻辑值。第 74 页的表 13-1 显示了 I/O 引脚的各种状态，但是我将在本系列的第 4 部分中详细介绍。

**循环**

嵌入式程序必须有一个无限循环，以防止程序到达结尾并退出。这是因为，如果我们的程序退出，芯片将只是坐在那里，什么也不做(毕竟，没有程序运行)。在这种情况下，我不需要循环做任何事情，因为我已经设置了硬件，并且我正在使用一个中断来闪烁 LED:

```
  while(1) { }			//Loop forever, interrupts do the rest
```

我将在第 4 部分或本系列文章中为循环添加功能，但现在‘while(1)’循环只是捕获程序，并不做任何其他事情。

**处理中断**

现在一切都准备好了，但是除非我们编写代码在中断发生后做一些事情，否则什么都不会发生。这被称为中断服务程序(ISR)。其余的代码被暂停，这个例程运行。最好尽量简短，这在这里很容易做到，因为我们只需要切换 LED:

```
ISR(TIMER1_COMPA_vect)		//Interrupt Service Routine
{
  PORTD ^= (1<<0);		//Use xor to toggle the LED
}
```

查看数据手册的第 62 页，可以看到定时器/计数器 1 比较匹配的中断源称为“定时器 1 COMPA”。我们将它作为 ISR 的输入变量，用下划线代替空格，并在末尾添加小写的“vect”。这就是编译器如何知道哪个 ISR 属于不同的中断源。至于 LED 本身，我使用了 XOR 运算符和一个位掩码。位掩码确保只有位 0 会被改变。

## 编译代码

在我们结束本系列教程之前，您应该对您的编译器进行一次测试。

编译器将我们的 C 代码转换成一个可以写入微控制器的文件。编译器的细节有点复杂，现在不是解释这些细节的时候。但是当你学习编写嵌入式代码时，你应该努力学习编译器如何解释这些代码。这样做可以避免许多由优化(编译器试图简化你臃肿的 C 代码)引起的麻烦，并且可以让你在编程空间和功能上充分利用你的硬件。

但是现在有一个 make 文件包含在第 2 部分的示例源代码[中。如果您还没有，解压该包并导航到“src”目录。该目录中有两个文件，main.c 和 makefile。makefile 是自动化编译过程的一种方式。这是一个编译、链接和编程的 C 代码源文件。如果您查看 makefile，您会注意到在顶部附近有几个用户设置。您需要设置您编写代码的微处理器、您编写的源文件的名称(TARGET = main)、您使用的程序员(来自第 2 部分讨论的 AVRdude 列表)以及程序员的端口路径。](https://github.com/szczys/had_AVRtut_2/archives/master)

如果您键入“make ”,您应该能够编译示例程序。除非你有一个 AVR Dragon 程序员，并且你正在运行 Linux，否则当它试图对芯片编程时，你会得到一个错误，但是它应该编译代码并输出几个额外的文件:

```
$  ls -la
total 84
drwxr-xr-x 2 mike mike  4096 2010-11-04 14:20 .
drwxr-xr-x 3 mike mike  4096 2010-11-01 14:55 ..
-rw-r--r-- 1 mike mike   894 2010-10-24 12:34 main.c
-rw-r--r-- 1 mike mike    23 2010-11-04 14:20 main.d
-rw-r--r-- 1 mike mike    13 2010-11-04 14:20 main.eep
-rwxr-xr-x 1 mike mike  7121 2010-11-04 14:20 main.elf
-rw-r--r-- 1 mike mike   750 2010-11-04 14:20 main.hex
-rw-r--r-- 1 mike mike  5224 2010-11-04 14:20 main.lss
-rw-r--r-- 1 mike mike  5171 2010-11-04 14:20 main.lst
-rw-r--r-- 1 mike mike 14464 2010-11-04 14:20 main.map
-rw-r--r-- 1 mike mike  3972 2010-11-04 14:20 main.o
-rw-r--r-- 1 mike mike  1454 2010-11-04 14:20 main.sym
-rw-r--r-- 1 mike mike 10235 2010-10-24 10:44 makefile
```

“main.hex”是可以在微控制器上编程的文件。这个 makefile 非常通用。您还可以看到，它输出“main.eep ”,如果您的代码包含 EEPROM 中存储的默认数据，则可以用它来对芯片上的 EEPROM 进行编程。它也可以被修改以输出一个汇编文件，或者不同格式的二进制文件。

如果你的编译器没有给出这些信息，那么你的工具链就有问题。使用你的朋友谷歌来搜索任何错误信息，看看你是否能解决问题。另一个很好的练习是修改这个文件，以便与您的程序员一起工作。如果您设法让 AVRdude 在本系列的第 2 部分中工作，这种改变就像更改 makefile 以使用那些相同的设置一样简单。

## 结论

暂时就这样了。在本系列的下一期文章中，我将讨论熔丝位，编写我们自己的代码，并尝试讨论该芯片的许多不同外设特性。我打算在原来的电路上增加几个发光二极管(所以要确保你至少有 8 个发光二极管和匹配的电阻)，并增加一个输入按钮。感谢阅读！

## **跟我来**

## 资源

Atmel AVR [ATmega168 数据表](http://www.atmel.com/dyn/resources/prod_documents/doc2545.pdf) (PDF)

[AVR Libc 手册](http://www.nongnu.org/avr-libc/user-manual/)